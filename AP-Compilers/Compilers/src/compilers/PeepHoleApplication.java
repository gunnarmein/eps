/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package compilers;

import java.util.LinkedList;
import vx86.Instruction;
import vx86.Vx86;

/**
 *
 * @author gmein
 */
public class PeepHoleApplication {

    public String name;
    public PeepHoleEngine.Pattern pattern;
    public PeepHoleEngine.Pattern substitution;

    PeepHoleApplication(String name) {
        this.name = name;
    }
    
    public static LinkedList<PeepHoleApplication> generateAllPatterns() {
        LinkedList<PeepHoleApplication> list = new LinkedList<>();
        list.add(generateLoopConditionPattern());
        list.add(generateCmpImmediatePattern());
        return list;
    }

    public static PeepHoleApplication generateLoopConditionPattern() {
        /*
        find this pattern, and replace transplant the marked parts
        this is for loop statements - the conditions are booleans (1 true 0 false). If it was a "BOTH SAEM" comparision, 
        it starts with a subtraction and then essentially has to invert its logic. This can be shortcut to two instructions:
        
        SUB  EAX,*EBX*           ; subtract to compare
        JZ   1                   ; 0 (equal)? go to inc to become 1 (true)
        MOV  EAX,-1              ; goes through inc and becomes 0 (false)
        INC  EAX   
        ----- above here was generated by BOTH SAEM, below by loop condition testing
        CMP  EAX,0               ; done?
        JNE  *8*                 ; done, leave loop    
        
        becomes
        CMP  EAX,*EBX*           ; done?
        JE   *8*                 ; done, leave loop
        
        in this pattern *EBX* and *8* are the variables of the patter which will be identified in the matching process
        
         */
        PeepHoleApplication pa = new PeepHoleApplication("LoopConditionPattern");
        PeepHoleEngine.Pattern pt = new PeepHoleEngine.Pattern();

        pt.add(new Instruction(Vx86.Inx.SUB, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.THIS, Vx86.Reg.ANY, "ANY"));
        pt.add(new Instruction(Vx86.Inx.JZ, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, Vx86.Mode.NONE, Vx86.Reg.NONE, 1));
        pt.add(new Instruction(Vx86.Inx.MOV, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, -1));
        pt.add(new Instruction(Vx86.Inx.INC, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.NONE, Vx86.Reg.NONE, 0));
        pt.add(new Instruction(Vx86.Inx.CMP, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, 0));
        pt.add(new Instruction(Vx86.Inx.JNE, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, Vx86.Mode.NONE, Vx86.Reg.NONE, "THAT"));
        pa.pattern = pt;

        // careful not to have any ANY in this pattern, and THIS and THAT only is you supply them from the search pattern
        PeepHoleEngine.Pattern sub = new PeepHoleEngine.Pattern();
        sub.add(new Instruction(Vx86.Inx.CMP, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.THIS, Vx86.Reg.THIS, "THIS", "same?"));
        sub.add(new Instruction(Vx86.Inx.JE, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, Vx86.Mode.NONE, Vx86.Reg.NONE, "THAT", "done, leave loop"));
        pa.substitution = sub;

        return pa;
    }

    public static PeepHoleApplication generateCmpImmediatePattern() {
        /*
        find this pattern, and replace transplant the marked parts
        we don't really need to load EBX just to compare EAX:
           
        MOV  EAX,[8]             
        MOV  *EBX*,*-1*              
        CMP  EAX,*EBX*           ; same?
        
        becomes
           
        CMP  EAX,*-1*            ; done?
        
        could do this with an extension of data flow, but that is hard. so let's get it here:
         */

        PeepHoleApplication pa = new PeepHoleApplication("cmpImmediatePattern");
        PeepHoleEngine.Pattern pt = new PeepHoleEngine.Pattern();

        pt.add(new Instruction(Vx86.Inx.MOV, Vx86.Mode.REGISTER, Vx86.Reg.THIS, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, "THAT"));
        pt.add(new Instruction(Vx86.Inx.CMP, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.REGISTER, Vx86.Reg.THIS, 0));
        pa.pattern = pt;

        // careful not to have any ANY in this pattern, and THIS and THAT only is you supply them from the search pattern
        PeepHoleEngine.Pattern sub = new PeepHoleEngine.Pattern();
        sub.add(new Instruction(Vx86.Inx.CMP, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, "THAT"));
        pa.substitution = sub;

        return pa;
    }
}
