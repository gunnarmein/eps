/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package compilers;

import java.util.LinkedList;
import vx86.Instruction;
import vx86.Vx86;

/**
 *
 * @author gmein
 */
public class PeepholeApplication {

    public String name;
    public PeepholeEngine.Pattern pattern;
    public PeepholeEngine.Pattern substitution;
    public int lineOfInterest = -1;

    PeepholeApplication(String name) {
        this.name = name;
    }

    public static LinkedList<PeepholeApplication> generateAllPatterns() {
        LinkedList<PeepholeApplication> list = new LinkedList<>();
        //
        // note: patterns will be applied in order listed here
        // so, you really want to run push/pop before you run push x/pop y
        //
        list.add(generateLoopConditionPattern());
        list.add(generateXXXEAXImmediatePattern());
        list.add(generateXXXEBXImmediatePattern());
        list.add(generateJmpZeroPattern());
        list.add(generatePushPopPattern());
        list.add(generatePushMovPopPattern());
        list.add(generatePushPopRegRegPattern());
        list.add(generatePushImmediatePattern());
        list.add(generatePushImmediate2Pattern());
        return list;
    }

    public static PeepholeApplication generateLoopConditionPattern() {
        /*
        find this pattern, and replace/transplant the marked parts
        this is for loop statements - the conditions are booleans (1 true 0 false). If it was a "BOTH SAEM" comparision, 
        it starts with a subtraction and then essentially has to invert its logic. This can be shortcut to two instructions:
        
        SUB  EAX,*EBX*           ; subtract to compare
        JZ   1                   ; 0 (equal)? go to inc to become 1 (true)
        MOV  EAX,-1              ; goes through inc and becomes 0 (false)
        INC  EAX   
        ----- above here was generated by BOTH SAEM, below by loop condition testing
        CMP  EAX,0               ; done?
        JNE  *8*                 ; done, leave loop    
        
        becomes
        CMP  EAX,*EBX*           ; done?
        JE   *8*                 ; done, leave loop
        
        in this pattern *EBX* and *8* are the variables of the patter which will be identified in the matching process
        
         */
        PeepholeApplication pa = new PeepholeApplication("LoopConditionPattern");
        PeepholeEngine.Pattern pt = new PeepholeEngine.Pattern();

        pt.add(new Instruction(Vx86.Inx.SUB, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.THIS, Vx86.Reg.ANY, "ANY"));
        pt.add(new Instruction(Vx86.Inx.JZ, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, Vx86.Mode.NONE, Vx86.Reg.NONE, 1));
        pt.add(new Instruction(Vx86.Inx.MOV, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, -1));
        pt.add(new Instruction(Vx86.Inx.INC, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.NONE, Vx86.Reg.NONE, 0));
        pt.add(new Instruction(Vx86.Inx.CMP, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, 0));
        pt.add(new Instruction(Vx86.Inx.JNE, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, Vx86.Mode.NONE, Vx86.Reg.NONE, "THAT"));
        pa.pattern = pt;

        // careful not to have any ANY in this pattern, and THIS and THAT only is you supply them from the search pattern
        PeepholeEngine.Pattern sub = new PeepholeEngine.Pattern();
        sub.add(new Instruction(Vx86.Inx.CMP, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.THIS, Vx86.Reg.THIS, "THIS", "same?"));
        sub.add(new Instruction(Vx86.Inx.JE, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, Vx86.Mode.NONE, Vx86.Reg.NONE, "THAT", "done, leave loop"));
        pa.substitution = sub;

        return pa;
    }

    public static PeepholeApplication generateXXXEBXImmediatePattern() {
        /*
        we don't really need to load EBX just to do something with the value and EAX:
           
        MOV  EAX,[8]             
        MOV  EBX,*-1*              
        *XXX*  EAX,EBX          
        
        becomes
           
        CMP  EAX,*-1*      
        
        could do this with an extension of data flow, but that is hard. so let's get it here:
         */

        PeepholeApplication pa = new PeepholeApplication("xxxEBXLoadingPattern");
        PeepholeEngine.Pattern pt = new PeepholeEngine.Pattern();

        pt.add(new Instruction(Vx86.Inx.MOV, Vx86.Mode.REGISTER, Vx86.Reg.EBX, Vx86.Mode.THAT, Vx86.Reg.THAT, "THAT"));
        pt.add(new Instruction(Vx86.Inx.THIS, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.REGISTER, Vx86.Reg.EBX, 0));
        pa.pattern = pt;

        // careful not to have any ANY in this pattern, and THIS and THAT only if you supply them from the search pattern
        PeepholeEngine.Pattern sub = new PeepholeEngine.Pattern();
        sub.add(new Instruction(Vx86.Inx.THIS, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.THAT, Vx86.Reg.THAT, "THAT"));
        pa.substitution = sub;

        //pa.lineOfInterest = 85;
        
        return pa;
    }

    public static PeepholeApplication generateXXXEAXImmediatePattern() {
        /*
        same thing for EAX
         */

        PeepholeApplication pa = new PeepholeApplication("xxxEAXImmediatePattern");
        PeepholeEngine.Pattern pt = new PeepholeEngine.Pattern();

        pt.add(new Instruction(Vx86.Inx.MOV, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, "THAT"));
        pt.add(new Instruction(Vx86.Inx.THIS, Vx86.Mode.REGISTER, Vx86.Reg.EBX, Vx86.Mode.REGISTER, Vx86.Reg.EAX, 0));
        pa.pattern = pt;

        // careful not to have any ANY in this pattern, and THIS and THAT only is you supply them from the search pattern
        PeepholeEngine.Pattern sub = new PeepholeEngine.Pattern();
        sub.add(new Instruction(Vx86.Inx.THIS, Vx86.Mode.REGISTER, Vx86.Reg.EBX, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, "THAT"));
        pa.substitution = sub;

        return pa;
    }

    public static PeepholeApplication generateJmpZeroPattern() {
        /*
        we don't like JMP 0
         */

        PeepholeApplication pa = new PeepholeApplication("jmpZeroPattern");
        PeepholeEngine.Pattern pt = new PeepholeEngine.Pattern();

        pt.add(new Instruction(Vx86.Inx.JMP, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, Vx86.Mode.NONE, Vx86.Reg.NONE, 0));
        pa.pattern = pt;

        PeepholeEngine.Pattern sub = new PeepholeEngine.Pattern();
        pa.substitution = sub;

        return pa;
    }

    public static PeepholeApplication generatePushPopPattern() {
        /*
        we don't like push exx/pop exx, it is stupid
        data flow analysis will fix this too, but anyway here is the example
         */

        PeepholeApplication pa = new PeepholeApplication("pushPopPattern");
        PeepholeEngine.Pattern pt = new PeepholeEngine.Pattern();

        // using THIS to make sure it is really the same operand being pushed and popped
        pt.add(new Instruction(Vx86.Inx.PUSH, Vx86.Mode.THIS, Vx86.Reg.THIS, Vx86.Mode.NONE, Vx86.Reg.NONE, "THIS"));
        pt.add(new Instruction(Vx86.Inx.POP, Vx86.Mode.THIS, Vx86.Reg.THIS, Vx86.Mode.NONE, Vx86.Reg.NONE, "THIS"));
        pa.pattern = pt;

        PeepholeEngine.Pattern sub = new PeepholeEngine.Pattern();
        // no substitution code for this one - empty pattern - just want it gone
        pa.substitution = sub;

        return pa;
    }

        public static PeepholeApplication generatePushImmediatePattern() {
        /*
         */

        PeepholeApplication pa = new PeepholeApplication("generatePushImmediatePattern");
        PeepholeEngine.Pattern pt = new PeepholeEngine.Pattern();

        pt.add(new Instruction(Vx86.Inx.MOV, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, "THIS"));
        pt.add(new Instruction(Vx86.Inx.PUSH, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.NONE, Vx86.Reg.NONE, 0));
        pt.add(new Instruction(Vx86.Inx.CALL, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, Vx86.Mode.NONE, Vx86.Reg.NONE, "THAT"));
        pa.pattern = pt;

        PeepholeEngine.Pattern sub = new PeepholeEngine.Pattern();
        sub.add(new Instruction(Vx86.Inx.PUSH, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, Vx86.Mode.NONE, Vx86.Reg.NONE, "THIS"));
        sub.add(new Instruction(Vx86.Inx.CALL, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, Vx86.Mode.NONE, Vx86.Reg.NONE, "THAT"));
        pa.substitution = sub;

        return pa;
    }

        
             public static PeepholeApplication generatePushImmediate2Pattern() {
        /*
         */

        PeepholeApplication pa = new PeepholeApplication("generatePushImmediate2Pattern");
        PeepholeEngine.Pattern pt = new PeepholeEngine.Pattern();

        pt.add(new Instruction(Vx86.Inx.MOV, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, "THIS"));
        pt.add(new Instruction(Vx86.Inx.PUSH, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.NONE, Vx86.Reg.NONE, 0));
        pt.add(new Instruction(Vx86.Inx.MOV, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.THAT, Vx86.Reg.THAT, "THAT"));
        pa.pattern = pt;

        PeepholeEngine.Pattern sub = new PeepholeEngine.Pattern();
        sub.add(new Instruction(Vx86.Inx.PUSH, Vx86.Mode.IMMEDIATE, Vx86.Reg.NONE, Vx86.Mode.NONE, Vx86.Reg.NONE, "THIS"));
        sub.add(new Instruction(Vx86.Inx.MOV, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.THAT, Vx86.Reg.THAT, "THAT"));
        pa.substitution = sub;
        
        return pa;
    }
    
    public static PeepholeApplication generatePushPopRegRegPattern() {
        /*
        we don't like push eXx/pop eYx, can do move instead
        data flow analysis will fix this too, but anyway here is the example
         */

        PeepholeApplication pa = new PeepholeApplication("pushPopRegRegPattern");
        PeepholeEngine.Pattern pt = new PeepholeEngine.Pattern();

        // using THIS and THAT to identifiy input and ouput register
        pt.add(new Instruction(Vx86.Inx.PUSH, Vx86.Mode.REGISTER, Vx86.Reg.THIS, Vx86.Mode.NONE, Vx86.Reg.NONE, 0));
        pt.add(new Instruction(Vx86.Inx.POP, Vx86.Mode.REGISTER, Vx86.Reg.THAT, Vx86.Mode.NONE, Vx86.Reg.NONE, 0));
        pa.pattern = pt;

        PeepholeEngine.Pattern sub = new PeepholeEngine.Pattern();
        sub.add(new Instruction(Vx86.Inx.MOV, Vx86.Mode.REGISTER, Vx86.Reg.THAT, Vx86.Mode.REGISTER, Vx86.Reg.THIS, 0));
        pa.substitution = sub;
        return pa;
    }

    public static PeepholeApplication generatePushMovPopPattern() {
        /*
        we don't like push eax/mov ebx, x/pop eax, can do move instead
        data flow analysis will fix this too, but anyway here is the example
         */

        PeepholeApplication pa = new PeepholeApplication("PushMovePopPattern");
        PeepholeEngine.Pattern pt = new PeepholeEngine.Pattern();

        pt.add(new Instruction(Vx86.Inx.PUSH, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.NONE, Vx86.Reg.NONE, 0));
        pt.add(new Instruction(Vx86.Inx.MOV, Vx86.Mode.THIS, Vx86.Reg.THIS, Vx86.Mode.THAT, Vx86.Reg.THAT, "THAT"));
        pt.add(new Instruction(Vx86.Inx.POP, Vx86.Mode.REGISTER, Vx86.Reg.EAX, Vx86.Mode.NONE, Vx86.Reg.NONE, 0));
        pa.pattern = pt;

        PeepholeEngine.Pattern sub = new PeepholeEngine.Pattern();
        sub.add(new Instruction(Vx86.Inx.MOV, Vx86.Mode.THIS, Vx86.Reg.THIS, Vx86.Mode.THAT, Vx86.Reg.THAT, "THAT"));
        pa.substitution = sub;
        return pa;
    }
}
